//0.7381
#pragma once

#include <algorithm>
#include <map>
#include <string>
#include <vector>
#include <Windows.h>

#include "機器學習.HPP"
#include "資料表.HPP"

class 類別_決策樹模型
{
private:
	class 類別_決策樹節點;
	class 類別_特征分裂;

	類別_決策樹節點* 丶決策樹根節點;

public:

	類別_決策樹模型()
	{
		丶決策樹根節點 = new 類別_決策樹節點();
	}

	virtual ~類別_決策樹模型()
	{
		delete 丶決策樹根節點;
	}

	void 訓練
	(
		類別_資料表* 丶資料表
		, double 丶標籤值陣列[]
		, unsigned __int64 丶特征欄索引陣列[]
		, unsigned __int64 特征數
		, double 丶梯度值陣列[]
		, double 丶海森值陣列[]
		, double 最大深度 = 10.0
		, double 最小均方根誤差 = 0.01
		, double 最小葉樣本數 = 512.0
		, double γ = 0.0
		, double λ = 0.0
		, __int32 執行緒數 = 4
	)
	{
		auto 丶當前列索引向量 = new std::vector<unsigned __int64>();

		for (auto 甲 = 0; 甲 < 丶資料表->列數; 甲++)
			丶當前列索引向量->push_back(甲);

		auto 丶當前節點 = 丶決策樹根節點;
		丶當前節點->樣本數 = 特征數;
		丶當前節點->深度 = 0;

		while (true)
		{
			auto 特征分裂 = 尋找最優特征分裂(丶資料表, 丶標籤值陣列, 丶當前列索引向量, 丶特征欄索引陣列, 特征數, 丶梯度值陣列, 丶海森值陣列, 最小葉樣本數, γ, λ, 執行緒數);
			if (特征分裂.特征欄索引 == -1)
			{
				auto 標籤和 = 0.0;
				for (auto 甲 = 0; 甲 < 丶當前列索引向量->size(); 甲++)
					標籤和 += 丶標籤值陣列[甲];

				丶當前節點->預測值 = 標籤和 / 丶當前列索引向量->size();
				do
				{
					if (丶當前節點 == 丶決策樹根節點)
						goto 訓練完成;
					丶當前節點 = 丶當前節點->丶父節點;
				} while (丶當前節點->狀態 == 1);
					
				丶當前列索引向量 = 丶當前節點->丶右列索引向量;
				丶當前節點->丶右列索引向量 = 0;
				丶當前節點->狀態++;
				丶當前節點 = 丶當前節點->丶右節點;
				continue;
			}

			丶當前節點->特征欄索引 = 特征分裂.特征欄索引;
			丶當前節點->特征分裂值 = 特征分裂.分裂值;
			丶當前節點->丶左節點 = new 類別_決策樹節點();
			丶當前節點->丶左節點->丶父節點 = 丶當前節點;
			丶當前節點->丶右節點 = new 類別_決策樹節點();
			丶當前節點->丶右節點->丶父節點 = 丶當前節點;

			auto 左 = 0ULL;
			auto 左和 = 0.0;
			auto 左方和 = 0.0;
			auto 丶左列索引向量 = new std::vector<unsigned __int64>();
			auto 右 = 0ULL;
			auto 右和 = 0.0;
			auto 右方和 = 0.0;
			auto 丶右列索引向量 = new std::vector<unsigned __int64>();
			for (auto 甲 = 0; 甲 < 丶當前列索引向量->size(); 甲++)
			{
				auto 值 = 丶資料表->資料[丶當前列索引向量->at(甲)][特征分裂.特征欄索引];
				auto 標籤值 = 丶標籤值陣列[丶當前列索引向量->at(甲)];
				if (值 <= 特征分裂.分裂值)
				{
					左++;
					左和 += 標籤值;
					左方和 += 標籤值 * 標籤值;
					丶左列索引向量->push_back(丶當前列索引向量->at(甲));
				}
				else
				{
					右++;
					右和 += 標籤值;
					右方和 += 標籤值 * 標籤值;
					丶右列索引向量->push_back(丶當前列索引向量->at(甲));
				}
			}

			auto 左均值 = 左和 / 左;
			auto 右均值 = 右和 / 右;
			auto 左均方根誤差 = pow(左方和 / 左 - 左和 * 左和 / 左 / 左, 0.5);
			auto 右均方根誤差 = pow(右方和 / 右 - 右和 * 右和 / 右 / 右, 0.5);

			丶當前節點->丶左節點->樣本數 = 左;
			丶當前節點->丶左節點->深度 = 丶當前節點->深度 + 1;
			丶當前節點->丶右節點->樣本數 = 右;
			丶當前節點->丶右節點->深度 = 丶當前節點->深度 + 1;

			auto 左否 = 左 >= 最小葉樣本數 && 左均方根誤差 >= 最小均方根誤差 && 丶當前節點->深度 < 最大深度;
			auto 右否 = 右 >= 最小葉樣本數 && 右均方根誤差 >= 最小均方根誤差 && 丶當前節點->深度 < 最大深度;
			if (丶左列索引向量->size() == 0 || 丶右列索引向量->size() == 0)
			{
				左否 = false;
				右否 = false;
			}

			丶當前節點->預測值 = (左和 + 右和) / (左 + 右);
			if (左否 && 右否)
			{
				delete 丶當前列索引向量;
				丶當前列索引向量 = 丶左列索引向量;
				丶當前節點->丶右列索引向量 = 丶右列索引向量;
				丶當前節點 = 丶當前節點->丶左節點;
			}
			else if (左否 && !右否)
			{
				delete 丶當前列索引向量;
				delete 丶右列索引向量;
				丶當前列索引向量 = 丶左列索引向量;
				丶當前節點->丶右節點->預測值 = 右均值;
				丶當前節點->狀態++;
				丶當前節點 = 丶當前節點->丶左節點;
			}
			else if (!左否 && 右否)
			{
				delete 丶當前列索引向量;
				delete 丶左列索引向量;
				丶當前列索引向量 = 丶右列索引向量;
				丶當前節點->丶左節點->預測值 = 左均值;
				丶當前節點->狀態++;
				丶當前節點 = 丶當前節點->丶右節點;
			}
			else
			{
				delete 丶當前列索引向量;
				delete 丶左列索引向量;
				delete 丶右列索引向量;

				丶當前節點->丶左節點->預測值 = 左均值;
				丶當前節點->丶右節點->預測值 = 右均值;

				do
				{
					if (丶當前節點 == 丶決策樹根節點)
						goto 訓練完成;
					丶當前節點 = 丶當前節點->丶父節點;
				} while (丶當前節點->狀態 == 1);

				丶當前列索引向量 = 丶當前節點->丶右列索引向量;
				丶當前節點->丶右列索引向量 = 0;
				丶當前節點->狀態++;
				丶當前節點 = 丶當前節點->丶右節點;
			}
		}

	訓練完成:
		//delete 丶標籤值向量;
		return;
	}

	void 預測(類別_資料表* 丶資料表, double 丶預測陣列[])
	{
		for (auto 甲 = 0; 甲 < 丶資料表->列數; 甲++)
			丶預測陣列[甲] = 丶決策樹根節點->預測值;

		if (丶決策樹根節點->特征欄索引 == -1)
			return;

		auto 丶當前節點 = 丶決策樹根節點;
		auto 丶當前列索引向量 = new std::vector<unsigned __int64>();
		for (auto 甲 = 0; 甲 < 丶資料表->列數; 甲++)
			丶當前列索引向量->push_back(甲);

		while (true)
		{
			丶當前節點->狀態 = 0;

			auto 丶左列索引向量 = new std::vector<unsigned __int64>();
			auto 丶右列索引向量 = new std::vector<unsigned __int64>();

			for (auto 甲 = 0; 甲 < 丶當前列索引向量->size(); 甲++)
			{
				if (丶資料表->資料[丶當前列索引向量->at(甲)][丶當前節點->特征欄索引] <= 丶當前節點->特征分裂值)
					丶左列索引向量->push_back(丶當前列索引向量->at(甲));
				else
					丶右列索引向量->push_back(丶當前列索引向量->at(甲));
			}

			auto 左否 = 丶當前節點->丶左節點->特征欄索引 != -1;
			auto 右否 = 丶當前節點->丶右節點->特征欄索引 != -1;

			if (左否 && 右否)
			{
				丶當前列索引向量 = 丶左列索引向量;
				丶當前節點->丶右列索引向量 = 丶右列索引向量;
				丶當前節點 = 丶當前節點->丶左節點;
			}
			else if (左否 && !右否)
			{
				auto 預測值 = 丶當前節點->丶右節點->預測();
				for (auto 甲 = 0; 甲 < 丶右列索引向量->size(); 甲++)
					丶預測陣列[丶右列索引向量->at(甲)] = 預測值;

				丶當前列索引向量 = 丶左列索引向量;
				丶當前節點->狀態++;
				丶當前節點 = 丶當前節點->丶左節點;
			}
			else if (!左否 && 右否)
			{
				auto 預測值 = 丶當前節點->丶左節點->預測();
				for (auto 甲 = 0; 甲 < 丶左列索引向量->size(); 甲++)
					丶預測陣列[丶左列索引向量->at(甲)] = 預測值;

				丶當前列索引向量 = 丶右列索引向量;
				丶當前節點->狀態++;
				丶當前節點 = 丶當前節點->丶右節點;
			}
			else
			{
				auto 左預測值 = 丶當前節點->丶左節點->預測();
				auto 右預測值 = 丶當前節點->丶右節點->預測();
				for (auto 甲 = 0; 甲 < 丶左列索引向量->size(); 甲++)
					丶預測陣列[丶左列索引向量->at(甲)] = 左預測值;

				for (auto 甲 = 0; 甲 < 丶右列索引向量->size(); 甲++)
					丶預測陣列[丶右列索引向量->at(甲)] = 右預測值;

				do
				{
					if (丶當前節點 == 丶決策樹根節點)
						goto 預測完成;
					丶當前節點 = 丶當前節點->丶父節點;
				} while (丶當前節點->狀態 == 1);

				丶當前節點->狀態++;
				丶當前列索引向量 = 丶當前節點->丶右列索引向量;
				丶當前節點 = 丶當前節點->丶右節點;
			}
		}

	預測完成:
		return;
	}

private:
	類別_特征分裂 尋找最優特征分裂
	(
		類別_資料表* 丶資料表
		, double 丶標籤值陣列[]
		, std::vector<unsigned __int64>* 丶當前列索引向量
		, unsigned __int64 丶特征欄索引陣列[]
		, unsigned __int64 特征數
		, double 丶梯度值陣列[]
		, double 丶海森值陣列[]
		, double 最小葉樣本數 = 512.0
		, double γ = 0.0
		, double λ = 0.0
		, __int32 執行緒數 = 4
	)
	{
		auto 丶最優特征執行緒引數 = reinterpret_cast<類別_尋找最優特征分裂執行緒引數*>(calloc(執行緒數, sizeof(類別_尋找最優特征分裂執行緒引數)));
		auto 丶事件控制代碼 = new void*[執行緒數];
		for (auto 子 = 0; 子 < 執行緒數; 子++)
		{
			丶事件控制代碼[子] = CreateEventW(0, 0, 0, 0);
			new(&丶最優特征執行緒引數[子]) 類別_尋找最優特征分裂執行緒引數(子, 丶事件控制代碼[子], 丶資料表, 丶標籤值陣列, 丶當前列索引向量, 丶特征欄索引陣列, 特征數, 丶梯度值陣列, 丶海森值陣列, 最小葉樣本數, γ, λ, 執行緒數);

			QueueUserWorkItem
			(
				[](void* 丶引數) -> unsigned long
				{
					auto 丶執行緒引數 = reinterpret_cast<類別_尋找最優特征分裂執行緒引數*>(丶引數);
					auto 序號 = 丶執行緒引數->序號;
					auto 事件控制代碼 = 丶執行緒引數->事件控制代碼;
					auto 丶資料表 = 丶執行緒引數->丶資料表;
					auto 丶標籤值陣列 = 丶執行緒引數->丶標籤值陣列;
					auto 丶當前列索引向量 = 丶執行緒引數->丶當前列索引向量;
					auto 丶特征欄索引陣列 = 丶執行緒引數->丶特征欄索引陣列;
					auto 特征數 = 丶執行緒引數->特征數;
					auto 丶梯度值陣列 = 丶執行緒引數->丶梯度值陣列;
					auto 丶海森值陣列 = 丶執行緒引數->丶海森值陣列;
					auto 最大葉樣本數 = 丶執行緒引數->最大葉樣本數;
					auto γ = 丶執行緒引數->Γ;
					auto λ = 丶執行緒引數->Λ;
					auto 執行緒數 = 丶執行緒引數->執行緒數;
					for (auto 甲 = 0ULL; 甲 < 特征數; 甲++)
					{
						if (丶特征欄索引陣列[甲] % 執行緒數 != 序號)
							continue;

						auto 最大打分 = -1.7976931348623158e+308;
						auto 最大打分分裂值 = 1e300 * 1e300 * 0;

						auto 樣本數量 = 丶當前列索引向量->size();

						auto 左 = 0.0;
						auto 左和 = 0.0;
						auto 左方和 = 0.0;
						auto 左梯和 = 0.0;
						auto 左海和 = 0.0;
						auto 右 = 樣本數量;
						auto 右和 = 0.0;
						auto 右方和 = 0.0;
						auto 右梯和 = 0.0;
						auto 右海和 = 0.0;

						auto 丶索引 = new unsigned __int64[樣本數量];
						for (auto 乙 = 0; 乙 < 樣本數量; 乙++)
						{
							丶索引[乙] = 丶當前列索引向量->at(乙);
							auto 標籤 = 丶標籤值陣列[丶索引[乙]];
							右和 += 標籤;
							右方和 += 標籤 * 標籤;
							右梯和 += 丶梯度值陣列[丶索引[乙]];
							右海和 += 丶海森值陣列[丶索引[乙]];
						}

						類別_排序引數 排序引數(丶資料表, 丶特征欄索引陣列[甲]);
						qsort_s
						(
							丶索引
							, 樣本數量
							, sizeof(double)
							, [](void * 丶引數, const void* 丶甲, const void* 丶乙) -> __int32
							{
								auto 丶排序引數 = reinterpret_cast<類別_排序引數*>(丶引數);
								auto 索引甲 = *reinterpret_cast<unsigned __int64*>(const_cast<void*>(丶甲));
								auto 索引乙 = *reinterpret_cast<unsigned __int64*>(const_cast<void*>(丶乙));
								if (丶排序引數->丶資料表->資料[索引甲][丶排序引數->欄索引] > 丶排序引數->丶資料表->資料[索引乙][丶排序引數->欄索引])
									return 1;
								if (丶排序引數->丶資料表->資料[索引甲][丶排序引數->欄索引] == 丶排序引數->丶資料表->資料[索引乙][丶排序引數->欄索引])
									return 0;
								return -1;
							}
							, &排序引數
						);

						auto 當前特征值 = 1e300 * 1e300 * 0;
						for (auto 乙 = 0; 乙 < 樣本數量; 乙++)
						{
							auto 標籤值 = 丶標籤值陣列[丶索引[乙]];
							auto 值 = 丶資料表->資料[丶索引[乙]][丶特征欄索引陣列[甲]];

							if (左 > 最大葉樣本數 / 4 && 右 > 最大葉樣本數 / 4 && 值 != 當前特征值)
							{
								auto 打分 = 0.0;
								if (isnan(丶梯度值陣列[0]))
									打分 = 左和 * 左和 / 左 - 左方和 + 右和 * 右和 / 右 - 右方和;
								else
									打分 = 左梯和 * 左梯和 / (左海和 + λ) + 右梯和 * 右梯和 / (右海和 + λ) - (左梯和 + 右梯和) * (左梯和 + 右梯和) / (左海和 + 右海和 + λ) - γ;

								if (打分 > 最大打分)
								{
									最大打分分裂值 = 當前特征值;
									最大打分 = 打分;
								}
							}

							左++;
							左梯和 += 丶梯度值陣列[丶索引[乙]];
							左海和 += 丶海森值陣列[丶索引[乙]];
							左和 += 標籤值;
							左方和 += 標籤值 * 標籤值;
							右--;
							右梯和 -= 丶梯度值陣列[丶索引[乙]];
							右海和 -= 丶海森值陣列[丶索引[乙]];
							右和 -= 標籤值;
							右方和 -= 標籤值 * 標籤值;

							當前特征值 = 值;
						}

						delete[] 丶索引;

						if (最大打分 > 丶執行緒引數->打分)
						{
							丶執行緒引數->特征欄索引 = 丶特征欄索引陣列[甲];
							丶執行緒引數->分裂值 = 最大打分分裂值;
							丶執行緒引數->打分 = 最大打分;
						}
					}

					SetEvent(事件控制代碼);
					return 0;
				}
				, &丶最優特征執行緒引數[子]
				, 0
			);
		}

		WaitForMultipleObjects(執行緒數, 丶事件控制代碼, 1, -1);
		delete[] 丶事件控制代碼;

		類別_特征分裂 最優特征分裂;

		for (auto 子 = 0ULL; 子 < 執行緒數; 子++)
		{
			if (丶最優特征執行緒引數[子].打分 > 最優特征分裂.打分)
			{
				最優特征分裂.特征欄索引 = 丶最優特征執行緒引數[子].特征欄索引;
				最優特征分裂.打分 = 丶最優特征執行緒引數[子].打分;
				最優特征分裂.分裂值 = 丶最優特征執行緒引數[子].分裂值;
			}
			丶最優特征執行緒引數[子].~類別_尋找最優特征分裂執行緒引數();
		}

		return 最優特征分裂;
	}

private:
	class 類別_決策樹節點
	{
	public:
		類別_決策樹節點* 丶父節點 = 0;
		類別_決策樹節點* 丶左節點 = 0;
		類別_決策樹節點* 丶右節點 = 0;
		unsigned __int64 樣本數 = -1;
		unsigned __int64 深度 = -1;
		unsigned __int64 特征欄索引 = -1;
		double 特征分裂值 = 1e300 * 1e300 * 0;
		double 預測值 = 1e300 * 1e300 * 0;
		double 狀態 = 0;
		std::vector<unsigned __int64>* 丶右列索引向量;

		virtual ~類別_決策樹節點()
		{
			if (丶左節點 != 0)
				delete 丶左節點;
			if (丶右節點 != 0)
				delete 丶右節點;
			if (丶右列索引向量 != 0)
				delete 丶右列索引向量;
		}

		double 預測()
		{
			return 預測值;
		}
	};

	class 類別_特征分裂
	{
	public:
		unsigned __int64 特征欄索引 = -1;
		double 分裂值 = 1e300 * 1e300 * 0;
		double 打分 = -1.7976931348623158e+308;
	};

	class 類別_尋找最優特征分裂執行緒引數
	{
	public:
		__int32 序號;
		void* 事件控制代碼;
		類別_資料表* 丶資料表;
		double* 丶標籤值陣列;
		std::vector<unsigned __int64>* 丶當前列索引向量;
		unsigned __int64* 丶特征欄索引陣列;
		unsigned __int64 特征數;
		double* 丶梯度值陣列;
		double* 丶海森值陣列;
		double 最大葉樣本數;
		double Γ;
		double Λ;
		__int32 執行緒數;
		unsigned __int64 特征欄索引 = -1;
		double 分裂值 = 1e300 * 1e300 * 0;
		double 打分 = -1.7976931348623158e+308;

		類別_尋找最優特征分裂執行緒引數
		(
			__int32 序
			, void* 控
			, 類別_資料表* 丶資
			, double 丶標[]
			, std::vector<unsigned __int64>* 丶當
			, unsigned __int64 丶特[]
			, unsigned __int64 特
			, double 丶梯[]
			, double 丶海[]
			, double 最
			, double γ
			, double λ
			, __int32 執
		) : 序號(序), 事件控制代碼(控), 丶資料表(丶資), 丶標籤值陣列(丶標), 丶當前列索引向量(丶當), 丶特征欄索引陣列(丶特), 特征數(特), 丶梯度值陣列(丶梯), 丶海森值陣列(丶海), 最大葉樣本數(最), Γ(γ), Λ(λ), 執行緒數(執)
		{
		}
	};

	class 類別_排序引數
	{
	public:
		類別_資料表* 丶資料表;
		unsigned __int64 欄索引;

		類別_排序引數(類別_資料表* 丶資, unsigned __int64 特) : 丶資料表(丶資), 欄索引(特)
		{
		}
	};

	class 類別_決策樹異常 : 類別_異常
	{
	public:
		類別_決策樹異常(unsigned __int16* 異) : 類別_異常(異)
		{

		}
	};
};

